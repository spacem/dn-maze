function skillsim() {
  // initialize all the images
  $('.jobsprite').each(function() {
    this.style.backgroundImage = "url('" + urls.mainbar + "/" + $TIMESTAMP + "jobicon_main.png')";
  });

  // is async, don't care when we get it
  $.getJSON(urls.job, function(data) {
    db = data;

    // have it stay a little
    dskills.each(function() {
      this.setAttribute('data-desc', 'hover');
      init_description(this);
    });
  });

  dskills.each(function() {
    var dom = $(this);
    var skillID = this.getAttribute('data-skill');
    var lvl = Job.Cache[skillID];
    var grayed = lvl[0] == 0 ? '_b' : '';
    var sprite = Job.Sprites[skillID];
    var techs = get_tech_count(skillID);
    sprite[1] *= -50;
    sprite[2] *= -50;

    this.style.background = "url('"+ urls.mainbar  +"/" + $TIMESTAMP + "skillicon" + sprite[0] + grayed + ".png') " + sprite[1] + "px " + sprite[2] + "px"; // initial setup
    this.getElementsByClassName('skill-bdr')[0].style.background = "url('" + urls.border + "') 100px 0";


    dom.find('.skill-lvl').text([lvl[0] + techs, lvl[3]].join('/'));
    
    var t = this;
    dom.on('mousedown', function(event) {
      if ($dpop.persist) {
        $dpop.update($dpop.persist[0], $dpop.persist);
      }
      skill_adj(event, t);
    });
    
    dom.on("swiperight",function(event) {
      if ($dpop.persist) {
        $dpop.update($dpop.persist[0], $dpop.persist);
      }
      skill_adj({ button: 0}, t);
    });
    dom.on("swipeleft",function(event) {
      if ($dpop.persist) {
        $dpop.update($dpop.persist[0], $dpop.persist);
      }
      skill_adj({ button: 2}, t);
    });
  });

  $('.panel-body').on('contextmenu', prevent_default);


  // the apply type
  $('#pvp').click(reverse('#pve', function() {
                    set_cookie("apply_type", 1);
                    Job.ApplyType = 1;
                    if ($dpop.persist) {
                      $dpop.update($dpop.persist[0], $dpop.persist);
                    }
                    return !0;
                  }));
  $('#pve').click(reverse('#pvp', function() {
                    set_cookie("apply_type", 0);
                    Job.ApplyType = 0;
                    if ($dpop.persist) {
                      $dpop.update($dpop.persist[0], $dpop.persist);
                    }
                    return !0;
                  }));

  // the level
  $('#lv93').click(reverse('#lv95', function() {
                    Job.MaxLevel = 93;
                    history_push();
                    refresh_sp(get_max_sp(), false);
                    if ($dpop.persist) {
                      $dpop.update($dpop.persist[0], $dpop.persist);
                    }
                  }));
  $('#lv95').click(reverse('#lv93', function() {
                    Job.MaxLevel = 95;
                    history_push();
                    refresh_sp(get_max_sp(), false);
                    if ($dpop.persist) {
                      $dpop.update($dpop.persist[0], $dpop.persist);
                    }
                  }));

  // the strictness
  $('#free').click(reverse('#strict', function() {
                     set_cookie('free', 1);
                     return Job.Free = true;
                   }));
  $('#strict').click(reverse('#free', strict_switch));

  var search = 0;
  $('#s').val('').on('input', function() {
    ++search;
    var search_set = search;

    var str = $('#s').val();

    setTimeout(function() {
      if (search != search_set) {
        return;
      }

      search = 0; // reset it

      var re;
      try {
        re = new RegExp(str, 'im');
      } catch (x) {
        return;
      }

      dskills.each(function() {
        var dom = $(this);
        if (str.length > 2) {
          update_description(this, dom);
          var opts = dom.data('bs.popover').options;

          // check title
          var text = opts.title.text();
          if (re.test(text)) {
            this.style.opacity = 1;
            return;
          }

          text = opts.content.clone();
          text.find('.hidden').remove();
          this.style.opacity = re.test(text.text()) ? 1 : .33;
        } else {
          this.style.opacity = 1;
        }
      });
    }, 100); // .1s delay
  });

  $('#level-btn').mousedown(resetBuild);
    
  function resetBuild() {
    var level = Job.MaxLevel;
    dskills.each(function() {
      var dom = $(this);
      var skillID = this.getAttribute('data-skill');
      var skill = db.Skills[skillID];
      var lvl = Job.Cache[skillID];

      // update skill lvl
      if (level <= Job.MaxLevel) {
        Job.Techs = {};
        lvl[0] = db.Skills[skillID].LevelLimit[0] == 1 ? 1 : 0;
        lvl[2] = 0;
        techs = 0;
      }

      if (level != Job.MaxLevel) {
        // calculate new max SP
        var newMax = 0;
        var absMax = skill.MaxLevel - skill.SPMaxLevel;
        for (var i = absMax, j = 1; i > 0; i--, j++) {
          if (skill.LevelLimit[i-1] <= level) {
            newMax = i;
            break;
          }

          if (skill.LevelLimit[j-1] <= level) {
            newMax = j;
          } else {
            break;
          }
        }

        lvl[1] = Math.min(newMax, absMax);
      }

      update_skill_icon(skillID, dom);
    });

    // update panels
    refresh_sp(get_max_sp(level), level <= Job.MaxLevel);

    // other caches to reset
    if (level <= Job.MaxLevel) {
      Job.TSP = [0,0,0];
      Job.SkillGroups = {};
      Job.BaseSkills = {};
    }
    Job.MaxLevel = level;

    update_progress();
    history_push();
  }

  $('#techs').click(techniques)
}

function update_progress() {
  var total_sp = get_total_sp();
  var max_sp = get_max_sp();
  var percent = (total_sp/max_sp) * 100;
  $('#max-progress').text(format(lang.progress.max, max_sp));
  $('#progress').css('width', percent + '%');
  $('#rem-progress').text(format(lang.progress.remaining, max_sp - total_sp));
  $('#curr-progress').text(format(lang.progress.curr, total_sp));
}

function set_opacity(dom, o) {
  if (o < 0 || o > 1) {
    return -1;
  }

  dom.css("opacity", o);
  return o;
};

function prevent_default(e) {
  e.preventDefault();
}

function num(v) {
  return parseInt(v);
}

function sum(p, c) {
  return p+c;
}

function get_total_sp() {
  return Job.TSP.reduce(sum);
}

function get_max_sp(level) {
  return Job.Levels.slice(0, level || Job.MaxLevel).reduce(sum);
}

function tag(t, cls, text) {
  return $(document.createElement(t))
                   .addClass(cls)
                   .text(text);
}

var ON = 'btn-primary', OFF = 'btn-default';
function reverse(rev, handler) {
  return function() {
    if (handler() === false) {
      return;
    }
    $(rev).removeClass(ON).addClass(OFF);
    $(this).addClass(ON);
    history_push();
  };
}

function strict_checker(setFree) {
  var modal = $('#modal');
  var title = $('#modal-title');
  var body = $('#modal-body');
  var changeable = true;
  var warnings = [];

  dskills.each(function() {
    var skillID = num(this.getAttribute('data-skill'));
    var lvl = Job.Cache[skillID];
    var skill = db.Skills[skillID];

    // make sure needsp is fine
    if (lvl[0] > 0) {
      if (!check_skill_reqs_state(skillID, skill, warnings)) {
        changeable = false;
        return;
      }

      if (!check_skill_groups(skillID, skill, warnings)) {
        changeable = false;
        return;
      }
    }
  });

  if (changeable && setFree) {
    Job.Free = false;
    set_cookie('free', 0);
  } else {
    title.text(lang.strict_title);
    body.empty().append(warnings.map(function(v) {
                          return tag('p', null, v);
                        }));
  }

  return changeable;
}

function strict_switch() {
  if (!strict_checker(true)) {
    $('#modal').modal('show');
    return false;
  }
  return true;
}

var build_chars = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_'.split('');
function history_push() {
  
  if(typeof dskills === 'undefined') {
    return;
  }

  var build_path = [];
  dskills.each(function() {
    var skillID = this.getAttribute('data-skill');
    var pos = Job.Sprites[skillID][3];
    var lvl = Job.Cache[skillID];
    var maybeMinus1 = db.Skills[skillID].LevelLimit[1-1] == 1 ? 1 : 0;
    var b = [build_chars[lvl[0] - maybeMinus1]];
    var techs = get_tech_count(skillID);
    if (techs > 0) {
      if (Job.Techs.Crest == skillID) {
        b.push('.');
      }

      if (Job.Techs.Weapon == skillID) {
        b.push("'");
      }

      ['Necklace', 'Earring', 'Ring1', 'Ring2'].forEach(function(key) {
        if (Job.Techs[key] == skillID) {
          b.push('!');
        }
      });

    }
    b.push();
    build_path[pos] = b;
  });

  var full_build_path = [];
  for (var i = 0; i < build_path.length; i++) {
    if (build_path[i] === undefined) {
      full_build_path.push('-');
    } else {
      full_build_path = full_build_path.concat(build_path[i]);
    }
  }

  history.pushState(Job, null, '/' + dnskillsim_region + '/' + Job.EnglishName + '-' + Job.MaxLevel + '/' + full_build_path.join(''));
}

function refresh_sp(max_sp, reset) {
  // job sp
  $('.panel').each(function(jobNum) {
    var spdom = $(this).find('.panel-heading').find('span');
    var sp = spdom.text().split('/').map(num);
    var sp_ratio = Job.SP[jobNum];
    sp[1] = num(max_sp * sp_ratio);

    if (reset) {
      sp[0] = 0;
    } else {
      sp[0] = Job.TSP[jobNum];
    }

    spdom.text(sp.join('/'));
  });

  update_progress();
}

window.addEventListener('popstate', function(e) {
  oldJob = e.state || jQuery.extend(!0, {}, $Job);
  oldJob.ApplyType = Job.ApplyType;
  oldJob.Free = Job.Free;
  Job = oldJob;

  dskills.each(function() {
    var dom = $(this);
    var skillID = this.getAttribute('data-skill');

    // update indivdual skills
    update_skill_icon(skillID, dom);
  });

  refresh_sp(get_max_sp(), false);

  var a = '#pvp', b = '#pve';
  if (Job.ApplyType) {
    a = '#pve', b = '#pvp';
  }
  $(a).removeClass(ON).addClass(OFF);
  $(b).addClass(ON);

  a = '#free', b = '#strict';
  if (Job.Free) {
    a = '#strict', b = '#free';
  }
  $(a).removeClass(ON).addClass(OFF);
  $(b).addClass(ON);

  if ($dpop.persist) {
    $dpop.update($dpop.persist[0], $dpop.persist);
  }
});

function set_cookie(name, value) {
    var d = new Date();
    d.setTime(d.getTime() + (356*24*60*60*1000));
    document.cookie = name + "=" + value + "; path=/; expires=" + d.toUTCString();
}

function format(str) {
  var args = Array.prototype.slice.call(arguments, 1);
  var s = '';
  var len = str.length;
  var idx = 0;
  for (var i = 0; i < len; i++) {
    var c1 = str[i], c2 = str[i + 1];
    if (c1 == '?') {
      if (c2 == '?') {
        ++i;
        s += '?';
      } else {
        if (args[idx] === undefined) {
          s += "";
        } else {
          s += args[idx];
        }
        idx++;
      }
    } else {
      s += c1;
    }
  }
  return s;
}

function skill_adj(e, element) {
  if (e.altKey) {
    return; // don't do anything
  }

  var dom = $(element);
  var skillID = num(element.getAttribute('data-skill')); // indexOf is strict
  var max = e.shiftKey || e.ctrlKey;
  var lvl = [].concat(Job.Cache[skillID]); // clone it
  var skill = db.Skills[skillID];
  var techs = get_tech_count(skillID);

  var prev = lvl[0];
  if (e.button == 0) { // left click
    lvl[0] = Math.min(lvl[1], max ? lvl[1] : lvl[0] + 1);
  } else if (e.button == 2) { // right click
    lvl[0] = Math.max(0, max ? 0 : lvl[0] - 1);
    if (skill.LevelLimit[1-1] == 1 && lvl[0] == 0) { // default case
      lvl[0] = 1;
    }
  }

  var panel = dom.closest('.panel');
  var spdom = panel.find('.panel-heading').find('span'); // do something later
  var sp = spdom.text().split('/').map(num);
  var jobNum = num(panel.data('job'));

  // find SP difference
  var diff = 0, end = Math.max(prev, lvl[0]), inc = prev < lvl[0], totalSP = get_total_sp(), maxSP = get_max_sp();
  if (inc) {
    for (var i = prev + 1; i <= lvl[0]; i++) {
      var s = skill.SkillPoint[i-1];
      if (sp[0] + diff + s > sp[1] || totalSP + diff + s > maxSP) {
        lvl[0] = i - 1;
        break;
      }

      diff += s;
    }
  } else {
    for (var i = prev; i > lvl[0]; i--) {
      var s = skill.SkillPoint[i-1];
      diff -= s;
      if (!Job.Free && !can_reduce_skill(skillID, skill, i - 1, jobNum, Job.TSP[jobNum] + diff)) {
        lvl[0] = i;
        diff += s;
        break;
      }
    }
  }

  if (prev == lvl[0] || lvl[0] + techs > skill.MaxLevel) {
    return; // do nothing
  }

  if (!Job.Free) {
    if (lvl[0] > prev) { // skill reduction
      if (!check_skill_reqs(skillID, skill)) {
        return;
      }

      if (!check_skill_groups(skillID, skill)) {
        return;
      }
    }
  }

  if (lvl[0] == 0 && techs > 0) {
    for (var tech in Job.Techs) {
      if (Job.Techs[tech] == skillID) {
        delete Job.Techs[tech];
      }
    }
    techs = 0;
  }

  // add skillgroup
  if (skill.SkillGroup) {
    var g = skill.SkillGroup;
    if (!Job.SkillGroups[g]) { // nothing exists
      Job.SkillGroups[g] = [];
    }

    var group = Job.SkillGroups[g];
    if (lvl[0] && group.indexOf(skillID) == -1) {
      group.push(skillID);
    } else if (!lvl[0] && group.indexOf(skillID) != -1) {
      Job.SkillGroups[g] = group.filter(function($skillID) { return $skillID != skillID });
    }
  }

  if (skill.BaseSkillID) {
    var b = skill.BaseSkillID;
    if (! Job.BaseSkills[b]) {
      Job.BaseSkills[b] = [];
    }
    var base = Job.BaseSkills[b];
    if (lvl[0] && base.indexOf(skillID) == -1) {
      base.push(skillID);
    } else if (!lvl[0] && base.indexOf(skillID) != -1) {
      Job.BaseSkills[b] = base.filter(function($skillID) { return $skillID != skillID });
    }
  }

  // SP adjustment
  sp[0] += diff;
  lvl[2] += diff;
  totalSP += diff;
  Job.TSP[jobNum] += diff;

  // panel update
  spdom.text(sp.join('/'));


  // icon update
  Job.Cache[skillID] = lvl;
  update_skill_icon(skillID, dom, techs);

  // hooks
  update_progress();
  // $dpop.update(element, dom);
  history_push();
}

function update_skill_icon(skillID, dom, techs) {
  if (techs === undefined) {
    techs = get_tech_count(skillID);
  }

  var lvl = Job.Cache[skillID];
  var thiz = dom[0];
  var image = thiz.style.backgroundImage.replace('_b.png', '.png');

  thiz.style.backgroundImage = lvl[0] ? image : image.replace('.png', '_b.png');

  dom.find('.skill-bdr')
     .removeClass('g')
     .addClass(lvl[0] ? null : 'g');

  dom.find('.skill-lvl')
     .removeClass('g b')
     .text([lvl[0] + techs, lvl[3]].join('/'))
     .addClass(techs == 1 ? 'g' : (techs == 2 ? 'b' : null));

}


function level_satisfied(skillID, level) {
  var lvl = Job.Cache[skillID];
  return lvl[0] >= level;
}

function check_skill_reqs(skillID, skill) {
  // check if sp total is satisfied
  if (skill.NeedSP) {
    for (var i = 0; i < 3; i++) {
      if (Job.TSP[i] < skill.NeedSP[i]) {
        return false;
      }
    }
  }

  // make sure parent skill is fine
  if (skill.ParentSkills) {
    if (skill.SkillGroup == 1 && Job.SkillGroups[1] && Job.SkillGroups[1].length) {
      if (!check_ult_reqs()) {
        return false;
      }
    } else {
      for (var $skillID in skill.ParentSkills) {
        if (! level_satisfied($skillID, skill.ParentSkills[$skillID])) {
          return false;
        }
      }
    }
  }

  var base = Job.BaseSkills[skill.BaseSkillID];
  if (base && base.indexOf(skillID) == -1 && base.length) {
    return false;
  }

  return true;
}

function check_ult_reqs() {
  var atleastone = false;
  if (Job.SkillGroups[1]) {
    Job.SkillGroups[1].forEach(function(skillID) {
      var skill = db.Skills[skillID];
      var one = true;
      for (var $skillID in skill.ParentSkills) {
        one &= level_satisfied($skillID, skill.ParentSkills[$skillID]);
      }

      atleastone |= one;
    });
  }

  return atleastone;
}

function check_skill_reqs_state(skillID, skill, warnings) {
  // check if sp total is satisfied
  if (skill.NeedSP) {
    for (var i = 0; i < 3; i++) {
      if (Job.TSP[i] < skill.NeedSP[i]) {
        if (warnings) {
          warnings.push(format(lang.warnings.tsp, db.Lookup[skill.NameID], Job.Names[i], skill.NeedSP[i]));
        }
        return false;
      }
    }
  }

  // make sure parent skill is fine
  if (skill.SkillGroup != 1 && skill.ParentSkills) { // doesn't matter for ults
    for (var $skillID in skill.ParentSkills) {
      if (! level_satisfied($skillID, skill.ParentSkills[$skillID])) {
        if(warnings) {
          warnings.push(format(lang.warnings.parent, db.Lookup[skill.NameID], db.Lookup[db.Skills[$skillID].NameID], skill.ParentSkills[$skillID]));
        }

        return false;
      }
    }
  }

  var base = Job.BaseSkills[skill.BaseSkillID];
  if (base && base.indexOf(skillID) != -1 && base.length > 1) {
    if (warnings) {
      base.forEach(function($skillID) {
        if ($skillID != skillID) {
          warnings.push(format(lang.warnings.base, db.Lookup[skill.NameID], db.Lookup[db.Skills[$skillID].NameID]));
        }
      });
    }

    return false;
  }

  return true;
}

// check skill group
function check_skill_groups(skillID, skill, warnings) {
  if (skill.SkillGroup) {
    var group = Job.SkillGroups[skill.SkillGroup];
    if (skill.SkillGroup == 1 && group && group.length) { // ultimate
      if (warnings) { // hate doing this kinda stuff, but :/
        if (!check_ult_reqs()) {
          group.forEach(function($skillID) {
            var $skill = db.Skills[$skillID];
            for (var $$skillID in $skill.ParentSkills) {
              if (! level_satisfied($$skillID, $skill.ParentSkills[$$skillID])) {
                var fmt = format(lang.warnings.parent, db.Lookup[$skill.NameID], db.Lookup[db.Skills[$$skillID].NameID], $skill.ParentSkills[$$skillID]);
                if (warnings.indexOf(fmt) == -1) {
                  warnings.push(fmt);
                }

                return;
              }
            }
          });
          return false;
        }
      }
    } else if (group && group.length) {
      var found = group.indexOf(skillID) != -1;
      if (warnings && group.length > 1 && found) {
        group.forEach(function($skillID) {
          if ($skillID != skillID) {
            warnings.push(format(lang.warnings.group, db.Lookup[skill.NameID], db.Lookup[db.Skills[$skillID].NameID]));
          }
        });
      }
      return group.length == 1 && found;
    }
  }

  return true;
}

function can_reduce_skill(skillID, skill, newLevel, jobNum, newJobSP) {
  for (var $skillID in db.Skills) {
    if ($skillID == skillID) {
      continue;
    }

    var $skill = db.Skills[$skillID];
    var lvl = Job.Cache[$skillID];

    // will this create an SP violation to any other skill?
    if ($skill.NeedSP) {
      if (lvl[0] && newJobSP < $skill.NeedSP[jobNum]) {
        return false;
      }
    }

    if (skill.SkillGroup == 1 && $skill.SkillGroup == 1 && lvl[0] > 0 && !newLevel) {
      var group = Job.SkillGroups[1];
      for (var $$skillID in $skill.ParentSkills) {
        if (!level_satisfied($$skillID, $skill.ParentSkills[$$skillID])) {
          return false;
        }
      }
    } else {
      // is this skill a parent of any other valid skill?
      if ($skill.ParentSkills && $skill.ParentSkills[skillID]) {
        if (lvl[0] && newLevel < $skill.ParentSkills[skillID]) {
          return false;
        }
      }
    }
  }

  return true;
}
var $body = $('body');
var $lang = lang.description;
function popover_placement(popover, td) {
  var parent = $(td).parent();
  var childen = parent.parent().children();
  if(childen.length <= 2) {
    return 'left';
  }
  var index = childen.index(parent);
  if(index >= 2) {
    return 'left';
  }
  else {
    return 'right';
  }
}
function init_description(thiz) {
  $(thiz).popover({animation: false,
                   html: true,
                   trigger: 'manual',
                   placement: popover_placement,
                   container: $body})
         .on('mouseenter', $dpop.mouseenter)
         .on('mouseleave', $dpop.mouseleave)
         .on('mousedown', $dpop.mousedown)
         .on('taphold', $dpop.mouseenter);
}

function update_description(thiz, dom) {
  var skillID = thiz.getAttribute('data-skill');
  var lvl = Job.Cache[skillID];
  var skill = db.Skills[skillID];
  var opts = dom.data('bs.popover').options;
  opts.title = tag('span', Job.ApplyType ? 's' :null, format($lang.name[Job.ApplyType], db.Lookup[skill.NameID]));
  var d = opts.content ? opts.content : desc_fields.clone(true);
  var techs = get_tech_count(skillID), tech_append = "";
  if (techs > 0) {
    tech_append = " +" + techs;
  }

  // non-level related fields - no conditions
  d.find('.dlvl').find('span:last').text(Math.max(1, lvl[0]) + tech_append);
  d.find('.dlimit').find('span:last').text(lvl[3]);
  if (lvl[2]) {
    d.find('.dtsp').show().removeClass('hidden').find('span:last').text(lvl[2]);
  } else {
    d.find('.dtsp').hide().addClass('hidden');
  }

  // non-level related fields - with conditions
  if (skill.NeedWeaponType) {
    d.find('.dweaps')
     .find('span:last')
     .text(skill.NeedWeaponType.map($d.weapon).join(', '));
  } else {
    d.find('.dweaps').remove();
  }

  var skillType = $lang.type.passive;
  switch(skill.SkillType) {
    case 0: switch(skill.DurationType) {
      case 0: skillType = $lang.type.instant; break;
      case 1: skillType = $lang.type.buff; break;
      case 2: skillType = $lang.type.debuff; break;
    }
    break;
    case 3: skillType = $lang.type.ex; break;
  }
  d.find('.dtype').find('span:last').text(skillType);


  var ele = $lang.element.none;
  switch(skill.Element) {
    case 0: ele = $lang.element.fire; break;
    case 1: ele = $lang.element.water; break;
    case 2: ele = $lang.element.light; break;
    case 3: ele = $lang.element.dark; break;
  }
  d.find('.dele').find('span:last').text(ele);


  // level related fields
  var curr = lvl[0] + techs;
  var nextLevelLimit = skill.LevelLimit[curr-1];
  var nextSkillPoint = skill.SkillPoint[curr];

  var curDecreaseSP = skill.DecreaseSP[Job.ApplyType][curr-1];
  var nextDecreaseSP = skill.DecreaseSP[Job.ApplyType][curr];

  var curDelayTime = skill.DelayTime[Job.ApplyType][curr-1];
  var nextDelayTime = skill.DelayTime[Job.ApplyType][curr];

  var curSkillExplanationID = skill.SkillExplanationID[Job.ApplyType][curr-1];
  var nextSkillExplanationID = skill.SkillExplanationID[Job.ApplyType][curr];

  var curSkillExplanationIDParam = skill.SkillExplanationIDParam[Job.ApplyType][curr-1];
  var nextSkillExplanationIDParam = skill.SkillExplanationIDParam[Job.ApplyType][curr];

  // level up req stuff
  if (nextLevelLimit) {
    d.find('.dreq').show().removeClass('hidden');
    d.find('.dreqlvl')
     .find('span:last')
     .removeClass('r')
     .addClass(Job.MaxLevel < nextLevelLimit ? 'r' : null)
     .text(nextLevelLimit);

    // sp by job req
    if (skill.NeedSP) {
      d.find('.dreqtsp')
       .empty()
       .append(skill.NeedSP.map($d.sp));
    } else {
      d.find('.dreqtsp').remove();
    }

    // skill level req
    if (skill.ParentSkills) {
      var arr = [];
      for (var $skillID in skill.ParentSkills) {
        var reqlvl = skill.ParentSkills[$skillID]
        var $lvl = Job.Cache[$skillID];
        arr.push(tag('div',
                     $lvl[0] < reqlvl ? 'r' : null,
                     format($lang.req.parent, db.Lookup[db.Skills[$skillID].NameID], reqlvl)));
      }
      d.find('.dreqskills')
       .empty()
       .append(arr);
    } else {
      d.find('.dreqskills').remove();
    }


    // stuff that shouldn't show when unnecessary
    var jobNum = dom.closest('.panel').data('job');
    var maxSP = get_max_sp();
    var jobSP = Job.TSP[jobNum];
    var totalSP = get_total_sp();

    d.find('.dreqsp')
     .find('span:last')
     .text(nextSkillPoint)
     .removeClass('r')
     .addClass((jobSP + nextSkillPoint > maxSP*Job.SP[jobNum] ||
                totalSP + nextSkillPoint > maxSP) ? 'r' : null);
  } else {
    d.find('.dreq').hide().addClass('hidden');
  }

  // apply type specific
  var decreaseSP = curDecreaseSP ? curDecreaseSP : nextDecreaseSP;
  if (decreaseSP) {
    d.find('.dmp')
     .removeClass('hidden')
     .show()
     .find('span:last')
     .text(decreaseSP);
  } else {
    d.find('.dmp').hide().addClass('hidden');
  }

  var delayTime = (curDelayTime ? curDelayTime : nextDelayTime) / 1000;
  if (delayTime) {
    d.find('.dcd')
     .removeClass('hidden')
     .show()
     .find('span:last')
     .text(format($lang.cd,  delayTime));
  } else {
    d.find('.dcd').hide().addClass('hidden');
  }


  // descriptions
  var explID = curSkillExplanationID ? curSkillExplanationID : nextSkillExplanationID;
  var explParams = curSkillExplanationIDParam ? curSkillExplanationIDParam : nextSkillExplanationIDParam;
  d.find('.dnowv').html(desc_format(db.Lookup[explID], explParams));
  if (curr == 0 || curr == skill.MaxLevel) { // level 0/maxed; no next, but show next/now
    d.find('.dnext').hide().addClass('hidden');
    d.find('.dnextdiv').hide();
  } else {
    d.find('.dnextdiv').show();
    d.find('.dnext').show().removeClass('hidden');
    d.find('.dnextv').html(desc_format(db.Lookup[nextSkillExplanationID],
                                       nextSkillExplanationIDParam));
  }

  opts.content = d;
}

function desc_tag(cls, field) {
  return tag('div', cls).append(tag('span', 'o', field + ': '), tag('span'));
}

var $d = {
  params: function(p) {
    if (p[0] == '{') {
      return db.Lookup[p.substring(1, p.length - 1)];
    } else {
      return p;
    }
  },
  weapon: function(w) {
    return db.Weapons[w];
  },
  sp: function(sp,i) {
    if (sp > 0) {
      return tag('span',
                 Job.TSP[i] < sp ? 'r' : null,
                 format($lang.req.tsp, Job.Names[i], sp));
    } else {
      return null;
    }
  }
};

var $dpop = {
  persist: null,
  mouseenter: function () {
    var dom = $(this), trigger = dom.data('desc');
    if (trigger == 'hover' && !$dpop.persist) {
      update_description(this, dom);
      dom.popover('show');
    }
  },
  mouseleave: function() {
    var dom = $(this), trigger = dom.data('desc');
    if (trigger == 'hover') {
      dom.popover('hide');
    }
  },
  mousedown: function(e) {
    if (e.button == 1) {
      prevent_default(e);
      var dom = $(this), trigger = dom.data('desc');
      $dpop.update(this, dom);
      if (trigger == 'hover') {
        dom.data('desc', 'mclick');
        $dpop.persist = dom;
      } else {
        dom.data('desc', 'hover');
        $dpop.persist = null;
      }
    }
    else {
      var dom = $(this), trigger = dom.data('desc');
      if (trigger == 'hover') {
        dom.popover('hide');
      }
    }
  },
  update: function(thiz, dom) {
    if ($dpop.persist && $dpop.persist.data('skill') != dom.data('skill')) {
      $dpop.persist.data('desc', 'hover').popover('hide');
      $dpop.persist = null;
    }

    dom.popover('hide');
    update_description(thiz, dom);
    dom.popover('show');
  }
};


function desc_format(str, params) {
  if (!str) return str;

  if(params) {
    params = params.split(',').map($d.params);
  
    for (var i = 0; i < params.length; i++) {
      str = str.replace('{' + i + '}', params[i]);
    }
  }

  var c = 0, w = 0, p = 0, newStr = "", startPos = 0;
  for (var i = 0; i < str.length - 1; i++) {
    switch (str.substr(i, 2)) {
      case "#y": case "#p": case "#r": case "#s": case "#v":
      if (c - w == 1) { // needed a closing </span>
        newStr += str.substring(startPos, i) + "</span><span class=\"" + str.substr(i+1,1) + "\">";
      } else {
        newStr += str.substring(startPos, i) + "<span class=\"" + str.substr(i+1,1) + "\">";
        c++;
      }

      startPos = i + 2;
      ++i;
      break;
      case "#w":
      if (w == c) { // early #w
        newStr +=  str.substring(startPos, i);
      } else {
        newStr += str.substring(startPos, i) + "</span>";
        w++;
      }

      startPos = i + 2;
      ++i;
      default:
      break;
    }
  }

  newStr = newStr + str.substr(startPos);

  if (c != w) {
    newStr = newStr + "</span>";
  }

  return newStr.replace(/\\n/g, "<br />");
}


var desc_fields = tag('div').append(
  desc_tag('dlvl', $lang.fields.lvl),
  desc_tag('dmp', $lang.fields.mp),
  desc_tag('dweaps', $lang.fields.weap),
  desc_tag('dtype', $lang.fields.type),
  desc_tag('dele', $lang.fields.element),
  desc_tag('dcd', $lang.fields.cd),
  desc_tag('dlimit', $lang.fields.limit),
  desc_tag('dtsp', $lang.fields.tsp),
  tag('div', 'divider dreq'),
  tag('div', 'dreq o', $lang.req.lvl_up),
  tag('div', 'dreq dreqlvl').append(
    tag('span', null, $lang.req.char_lvl),
    tag('span')
  ),
  tag('div', 'dreq dreqskills'),
  tag('div', 'dreq dreqtsp'),
  tag('div', 'dreq dreqsp').append(
    tag('span', null, $lang.req.sp),
    tag('span')
  ),
  tag('div', 'dnow').append(
    tag('div', 'dnowf o', $lang.curr),
    tag('div', 'dnowv')
  ),
  tag('div', 'divider dnextdiv'),
  tag('div', 'dnext').append(
    tag('div', 'dnextf o', $lang.next),
    tag('div', 'dnextv')
  )
);

var techHTML;
function techniques() {
  var modal = $('#modal');
  var title = $('#modal-title');
  var body = $('#modal-body');

  title.text("Techniques");
  body.empty();
  if (!techHTML) {
    body.text('Loading data...');
    body.load('/api/' + dnskillsim_region + '/tech/' + Job.EnglishName, function(res) {
      techHTML = res;
      init_techs();
    });
  } else {
    body.html(techHTML);
    init_techs();
  }

  modal.modal('show');
}

function init_techs() {
  var ids = ['necklace', 'earring', 'ring-1', 'ring-2', 'weapon', 'crest'];
  var keys = ['Necklace', 'Earring', 'Ring1', 'Ring2', 'Weapon', 'Crest'];
  ids.forEach(function(id, i) {
    var tech = $('#tech-' + id);
    var btn = tech.next();
    var skillID = Job.Techs[keys[i]];
    if (skillID) { // already has something at start
      tech.val(skillID).prop('disabled', true);
      btn.removeClass('btn-default').addClass('btn-danger').text('-1');
    }

    btn.prop('disabled', !tech.val() || !skillID);
    tech.change(function() {
      var val = tech.val();
      btn.removeClass('btn-default btn-primary')
         .addClass(val ? 'btn-primary' : 'btn-default')
         .prop('disabled', !val);
    });

    btn.click(function() {
      var skillID = Job.Techs[keys[i]];
      btn.removeClass('btn-default btn-primary btn-danger');
      if (skillID) { // remove tech
        delete Job.Techs[keys[i]];
        btn.text('+1').addClass('btn-primary');
      } else { // add tech
        Job.Techs[keys[i]] = skillID = num(tech.val());
        btn.text('-1').addClass('btn-danger');
      }

      var dom = $('.skill').filter('[data-skill=' + skillID + ']');
      update_skill_icon(skillID, dom);
      if ($dpop.persist && $dpop.persist.data('skill') == skillID) {
        $dpop.update(dom[0], dom);
      }
      tech.prop('disabled', !skillID);
      tech_disable(Job.Techs);
      history_push();
    });
  });

  tech_disable(Job.Techs);
}

function get_tech_count(techs, skillID) {
  if (skillID === undefined) {
    skillID = techs;
    techs = Job.Techs;
  }

  var c = 0;
  for (var key in techs) {
    if (techs[key] == skillID) {
      c++;
    }
  }

  return c;
}

function tech_disable(techs) {
  // general disabling
  var ids = ['necklace', 'earring', 'ring-1', 'ring-2', 'weapon'];
  var keys = ['Necklace', 'Earring', 'Ring1', 'Ring2', 'Weapon'];

  $('.modal').find('option:disabled').prop('disabled', false); // re-enable for now

  for (var i = 0; i < keys.length; i++) {
    var skillID = techs[keys[i]];
    if (!skillID) {
      continue;
    }

    var remainder = [].concat(ids);
    remainder.splice(i,1); // take out self
    remainder.forEach(function(id) {
      if (techs[keys[ids.indexOf(id)]] != skillID) {
        disable_skill_tech($('#tech-' + id), skillID);
      }
    });

    var lvl = Job.Cache[skillID];
    var skill = db.Skills[skillID];
    var counts = get_tech_count(techs, skillID);
    if (lvl[0] + counts >= skill.MaxLevel && techs.Crest != skillID) {
      disable_skill_tech($('#tech-crest'), skillID);
    }
  }

  // disable from crest
  var skillID = techs.Crest;
  if (skillID) {
    var lvl = Job.Cache[skillID];
    var skill = db.Skills[skillID];
    var counts = get_tech_count(techs, skillID);
    if (lvl[0] + counts >= skill.MaxLevel) {
      ids.forEach(function(id, idx) {
        if (techs[keys[idx]] != skillID) {
          disable_skill_tech($('#tech-' + id), skillID);
        }
      });
    }
  }

  // disable lvl 0 skills
  ids.push('crest');
  ids.forEach(function(id) {
    var tech = $('#tech-' + id);
    for (var skillID in db.Skills) {
      var lvl = Job.Cache[skillID];
      if (!lvl[0]) {
        disable_skill_tech(tech, skillID);
      }
    }
  });
}

function disable_skill_tech(tech, skillID) {
  var btn = tech.next();
  if (tech.val() == skillID) { // don't keep it selected
    tech.val('');
    btn.removeClass('btn-primary btn-danger')
       .addClass('btn-default')
       .prop('disabled', true)
       .text('+1');
  }

  // disable the option
  var opt = tech.find('option[value=' + skillID + ']');
  if (opt.length) {
    opt.prop('disabled', true);
  }
}

//# sourceMappingURL=maze.min.js.map
